/**********************************************************************************************************************
 * \file Vacd.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "IfxVadc_Adc.h"
#include "Vadc.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/

/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxVadc_Adc g_vadc;
IfxVadc_Adc_Group adcGroup[2];
IfxVadc_Adc_Channel adcChannel_master[8];
IfxVadc_Adc_Channel adcChannel_slave[8];
/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

void initAdc(void)
{
    IfxVadc_Adc_Config adcConfig;
    IfxVadc_Adc_initModuleConfig(&adcConfig, &MODULE_VADC);
    IfxVadc_Adc_initModule(&g_vadc, &adcConfig);

    // Configure  ADC channel
    IfxVadc_Adc_GroupConfig adcGroupConfig[2];
    IfxVadc_Adc_ChannelConfig channelConfig_master[8];
    IfxVadc_Adc_ChannelConfig channelConfig_slave[8];

    IfxVadc_Adc_initGroupConfig(&adcGroupConfig[0], &g_vadc);
    adcGroupConfig[0].groupId = IfxVadc_GroupId_2;
    adcGroupConfig[0].master = IfxVadc_GroupId_2;

    adcGroupConfig[0].arbiter.requestSlotQueueEnabled   = TRUE;
    adcGroupConfig[0].arbiter.requestSlotScanEnabled    = TRUE;
    adcGroupConfig[0].arbiter.requestSlotBackgroundScanEnabled = TRUE;

    adcGroupConfig[0].scanRequest.autoscanEnabled = TRUE;
    adcGroupConfig[0].scanRequest.triggerConfig.triggerMode = IfxVadc_TriggerMode_uponFallingEdge;
    adcGroupConfig[0].scanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_15;
    adcGroupConfig[0].scanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
    adcGroupConfig[0].scanRequest.triggerConfig.gatingSource = IfxVadc_GatingSource_0;
    adcGroupConfig[0].scanRequest.requestSlotPrio = IfxVadc_RequestSlotPriority_low;

    adcGroupConfig[0].queueRequest.flushQueueAfterInit = TRUE;
    adcGroupConfig[0].queueRequest.triggerConfig.triggerMode = IfxVadc_TriggerMode_uponFallingEdge;
    adcGroupConfig[0].queueRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_15;
    adcGroupConfig[0].queueRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
    adcGroupConfig[0].queueRequest.triggerConfig.gatingSource = IfxVadc_GatingSource_0;
    adcGroupConfig[0].queueRequest.requestSlotPrio = IfxVadc_RequestSlotPriority_low;


    IfxVadc_Adc_initGroup(&adcGroup[0], &adcGroupConfig[0]);
    int chnlIdx = 0;
    for(chnlIdx = 0; chnlIdx < 8; chnlIdx++)
    {
        IfxVadc_Adc_initChannelConfig(&channelConfig_master[chnlIdx], &adcGroup[0]);
        channelConfig_master[chnlIdx].channelId = (IfxVadc_ChannelId)chnlIdx;
        channelConfig_master[chnlIdx].resultRegister = (IfxVadc_ChannelResult)chnlIdx;
        IfxVadc_Adc_initChannel(&adcChannel_master[chnlIdx],&channelConfig_master[chnlIdx]);
        uint32 enableChnBit = (1 << channelConfig_master[chnlIdx].channelId);   /* Set the the corresponding input channel  */
        uint32 mask = enableChnBit;                                     /* of the respective group to take part in  */
        IfxVadc_Adc_setScan(&adcGroup[0], enableChnBit, mask);
    }

    IfxVadc_Adc_initGroupConfig(&adcGroupConfig[1], &g_vadc);
    adcGroupConfig[1].groupId = IfxVadc_GroupId_3;
    adcGroupConfig[1].master = IfxVadc_GroupId_2;

    adcGroupConfig[1].arbiter.requestSlotQueueEnabled = TRUE;
    adcGroupConfig[1].arbiter.requestSlotScanEnabled = TRUE;
    adcGroupConfig[1].arbiter.requestSlotBackgroundScanEnabled = TRUE;

    adcGroupConfig[1].scanRequest.autoscanEnabled = TRUE;
    adcGroupConfig[1].scanRequest.triggerConfig.triggerMode = IfxVadc_TriggerMode_uponFallingEdge;
    adcGroupConfig[1].scanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_15;
    adcGroupConfig[1].scanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
    adcGroupConfig[1].scanRequest.triggerConfig.gatingSource = IfxVadc_GatingSource_0;
    adcGroupConfig[1].scanRequest.requestSlotPrio = IfxVadc_RequestSlotPriority_low;

    adcGroupConfig[1].queueRequest.flushQueueAfterInit = TRUE;
    adcGroupConfig[1].queueRequest.triggerConfig.triggerMode = IfxVadc_TriggerMode_uponFallingEdge;
    adcGroupConfig[1].queueRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_15;
    adcGroupConfig[1].queueRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
    adcGroupConfig[1].queueRequest.triggerConfig.gatingSource = IfxVadc_GatingSource_0;
    adcGroupConfig[1].queueRequest.requestSlotPrio = IfxVadc_RequestSlotPriority_low;

    IfxVadc_Adc_initGroup(&adcGroup[1], &adcGroupConfig[1]);
    for(chnlIdx = 0; chnlIdx < 8; chnlIdx++)
    {
        IfxVadc_Adc_initChannelConfig(&channelConfig_slave[chnlIdx], &adcGroup[1]);
        channelConfig_slave[chnlIdx].channelId = (IfxVadc_ChannelId)chnlIdx;
        channelConfig_slave[chnlIdx].resultRegister = (IfxVadc_ChannelResult)chnlIdx;
        IfxVadc_Adc_initChannel(&adcChannel_master[chnlIdx],&channelConfig_slave[chnlIdx]);
        uint32 enableChnBit = (1 << channelConfig_slave[chnlIdx].channelId);   /* Set the the corresponding input channel  */
        uint32 mask = enableChnBit;                                     /* of the respective group to take part in  */
        IfxVadc_Adc_setScan(&adcGroup[1], enableChnBit, mask);
    }
    // Start ADC
    IfxVadc_Adc_startScan(&adcGroup[0]);
    IfxVadc_Adc_startScan(&adcGroup[1]);
}
void adc_getData(void)
{

}
//uint16 readADCValue(uint8 channel)
//{
//    Ifx_VADC_RES conversionResult;
//    do
//    {
//        conversionResult = IfxVadc_Adc_getResult(&g_vadcChannel[channel]);
//    } while(!conversionResult.B.VF);
//
//    return conversionResult.B.RESULT;
//}
